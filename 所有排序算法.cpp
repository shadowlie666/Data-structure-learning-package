/* 
https://blog.csdn.net/bluesliuf/article/details/89043746?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164303160516780271520385%25
22%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164303160516780271520385&biz_id=0&utm_medium=distribute.pc_search_resu
lt.none-task-blog-2~all~top_positive~default-3-89043746.pc_search_insert_es_download&utm_term=c%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E
6%B3%95&spm=1018.2226.3001.4187
*/
# include <stdio.h>

//直接插入法(升序排序)：就是一个个的排序，先默认第一个元素已经排序了，从第二个元素开始，
//保存选取的位置的有效数据，从选取位置开始往前搜索
//如果发现选取位置左边的数据大于保存的有效数据，那么就将这个位置的数据往右边挪一个位置，然后继续往左搜索
//如果发现选取位置左边的数据小于保存的有效数据，那么就把保存的有效数据放到这个数据的右边
//选取下一个位置的元素，重复执行2.3.4行的操作 
void InsertSort1(int a[], int n)//一个是待排序数组，一个是数组元素个数 
{
    int i, j;
    for(i=1; i<n; i++)//默认第一个元素以排序，从第二个开始（即使第一个不是最小的，后面也会让这个元素往后移的） 
        if(a[i] < a[i-1])   
        {
            int temp = a[i];                       //保存要比较的值
            for(j=i-1; j>=0 && a[j]>temp; j--)    //以选择元素为起始点，从后向前查找待插入位置
                a[j+1] = a[j];                    //挪位
            a[j+1] = temp;                       //复制到插入位置
        }
}

//冒泡排序 
int sort(int *a, int n)
{
	int i, j, t; 
	
	for(i=0; i<n-1; i++)     //第一个for循环是用来确认要循环多少次的 
	{
		for(j=0; j<n-1-i; j++)  //第二个for循环使用来确认某次比较时比较到a[几]就停止继续比较，转入下一次循环的 
		{
			if(a[j]<a[j+1])      //冒泡排序思路：比如这里有五个数字，第一第二个比，小的那个放到后面去，第二第三个比，小的那个放到后面去
			{                   //这样下去，每次比较都是把小的放到后面，每次比较都是用前一次比较小的那个数字拿来比较的，所以当最后一次比较完成后 
				t = a[j];       //所有数字中最小的那个就放到最后面了，之后把最后那个最小的数字剔除掉，比较剩下的4个数字，再用同样的方法把最小的 
				a[j] = a[j+1]; //那个数字放到最后面（如果算上那个被剔除的最小数字，第二次比较的最小的数字就在倒数第二位），以此类推下去， 
				a[j+1] = t; //找出5个数字中的最值要比较4次，找出4个数字的最值要比较3次，所以第一次循环要比较4次，第二次循环要来3次。。  （第9行） 
			}               //给5个数字排序要循环4次，第一次找5个数字最值放到最后面，第二次找4个数字最值放到后面。。。    （第7行） 
			else ;
		}
	}
}

//快速排序：大致思路就是定义一个基数，将比基数小的数放到左边，比基数大的数放到右边，然后把基数放回中间，然后再对基数左边的再排序，
//对基数右边的也再次排序，直到递归传递的两个实参left和right相等（说明需要排序的数组里面只剩下一个元素了），停止排序

//i左j右，对i操作时，没有动i的元素就右移i，继续对i操作；动了i的元素就左移j，转为对j操作
//对j操作时，没有动j的元素就左移j，继续对j操作，动了j的元素就右移i，转为对i操作 

//定义两个变量ij分别指向最左边和最右边的数组位置，将最左边的基准数拿出来，先对j操作，如果j下标位置的元素比基数小就把这个数放到i的位置上（i上的
//数已经作为基数拿出来了），然后将i右移，然后就对i下标的元素操作，如果j位置的元素比奇数大就不进行操作然后将j左移，继续对j下标元素进行比较操作
//对i操作时，如果i位置上的元素比基数大就把这个数放到j位置上（上面两步中j上的元素一定是移走的了，没有移走会继续对j操作，此时j上的元素一定为空） 
//然后将j左移，然后转为对i操作，如果i位置上的元素比基数小就不进行操作，将i右移继续对i下标的元素进行比较操作 
void QuickSort(int a[],int left,int right)  //a接收的是数组，left~right是数组中需要排序的部分的两侧元素下标
{  
    if(left<right)
	{
        int i=left,j=right；
        int base=a[left];             //一般以最左侧元素基准
        while(i<j)
		{
            while(i<j&&a[j]>=base)    //先对j操作， 没有动j的元素就左移j，继续对j操作
                j--;
            if(i<j)	
			{
				a[i]=a[j];			// 动了j的元素就右移i，转为对i操作
				i++; 
			}				
            while(i<j&&a[i]<base)    // 然后对i操作， 没有动i的元素就右移i，继续对i操作
                i++;
            if(i<j)
			{
				 a[j]=a[i];			//动了i的元素就左移j，转为对j操作
				 j--;
			}					
        }
        a[i]=base;                  //将基准base填入中间分界线 
        QuickSort(a,left,i-1);      //递归调用，对基数左边的数再次排序 
        QuickSort(a,i+1,right);     //递归调用，对基数右边的数再次排序
    } 
}

//选择排序,以升序为例
//选择排序就是假定第一个数最小，然后寻找第一个数后面的数有没有比它更小的，有就交换，没有就假定第二个数最小，寻找第二个数后面有没有比它更小的 
void SelectSort(int a[],int n) //n是数组个数 
{
    int i,j,min,t; 
    for(i=0;i<n-1;i++)  //这个for循环是排序次数，n个数只需要排序n-1次，最后只剩一个数不需要排序 
	{
        min=i;
        for(j=i+1;j<n;j++)  //这个for循环是寻找下标为i的元素后面有没有比它更小的数 
		{
            if(a[j]<a[min)  //如果有就改变下标记号min为那个更小的数的下标 
                min=j;
        }
        if(min!=i)   //如果有找到比下标为i的元素更小的值，那么下标记号min和假定最小数下标i一定不会相等 
		{	   
			t = i;     //把更小的数换到前面来
			i = min;
			min = t;
		}
    }
}


int main(void)
{		
	return 0;
}
