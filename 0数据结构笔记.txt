1.数据结构的定义：我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及再次基础上
                              为实现某个功能（比如查找或删除某个元素）而执行的操作，这个操作也叫算法。
2.数据结构+个体+个体的关系
   算法 = 对存储数据的操作，解题的方法和步骤
3.衡量算法的标准
     一：时间复杂度：大概程序要执行的次数，而非执行时间（因为时间受硬件影响，不同机器对同一算法的影响很大）
     二：空间复杂度：算法执行过程中大概所占用的最大内存
     三：难易程度
     四：健壮性（容错性），像验证码一样，不能说大小写错了一点就全错
4.一个字节一个地址，指针接收的都是变量第一个字节的地址  
5.数据结构分为线性结构和非线性结构
  线性结构：连续存储--数组              离散存储--链表
         应用：栈，队列
  非线性结构，树，图
6.线性结构：把所有的节点用一根直线串起来
7.       exit（-1）；         终止整个函数
     注意这个函数需要调用<stdlib.h>工具
8.typedef的四种用法，见 【15】
9.链表的定义：所有节点不连续分配，节点之间通过指针相连，每个节点只有一个前驱节点和一个后续接点（线性排列）
                       并且首节点没有前驱节点，尾节点没有后续节点
10.单链表：一个结构体有一个指针域，第一个结构体可以指向第二个结构体，但第二个结构体不指向第一个结构体
     双链表，一个结构体有两个指针域，第一个结构体指向第二个结构体，第二个结构体也指向第一个结构体
     循环链表：能通过任何一个节点找到其他所有的节点
11.如何插入一个链表节点（方法一）
     前言：p指向第一个节点，q指向待插入节点，r为中间指针变量
     代码：r = p->pnext       由于p的指针域本来就指向第二个节点的，所以这里就是先让r指向第二个节点
	p->pnext = q    然后再断掉第一个节点和第二个节点的关系，让第一个节点的指针域指向待插入节点
	q->pnext = r      最后让待插入节点的指针域指向保留了第二个节点地址的r指针
注意：结构体本身是无法直接表示出来的，都是通过指针才能读取结构体内的元素内容，
思路：所以这个方法的思路就是因为要插入一个节点，所以第一个节点就不能再指向第二个节点了，要指向待插入节点，所以要先保留第二个节点的地址，
          确保第一个节点的指针域变换后第二个节点不丢失，所以要一个中间指针指向第二个节点之后就可以放心让第一个节点指向待插入节点了，最后要让
         待插入节点指向第二个节点，保证第一个节点->待插入节点->第二个节点的链表完整，由于只有中间指针保留了第二个节点的地址，所以待插入节点
         应该指向中间指针，这样才能指向第二个节点
12.如何插入一个节点（方法2）【这个好】
     前言：p指向第一个节点，q指向待插入节点
     代码：q->pnext = p->pnext
	p->pnext = q
     思路：这里就是省略了中间指针的过程，思路就是直接让待插入节点指向第二个节点，然后第一个节点指向待插入节点
     注意：看第二行，p->pnext就是p所指向的第一个节点的指针域，这个指针域本质上也是一个指针，q也是一个指针，这行代码属于指针之间的相互等于
                效果就是两个指针完全相同，那么p->pnext和q所指向的东西也相同了，即都指向待插入节点
13.如何删除一个节点
     代码：r = p->pnext
	p->pnext = p->pnext->pnext
	free(r)
     解释：这串代码的核心是第二行，但灵魂是第一第三行代码
               删除一个节点只需要让第一个节点的指针域指向第三个节点就行了，也就是让第一个节点的指针域指向第二个节点指针域所指向的第三个节点
               但问题是第二个节点没有删除掉，它的内存没有被释放，会使电脑内存越来越少，所以这里需要一个中间指针，让中间指针指向第二个节点，然后
               再让第一个节点指向第三个节点，最后释放掉r所指向的第二个节点的内存
    注意：free（p）的解释
              如果p是一个指针，那么释放的就是p所指向的空间的内存，不是释放p本身
              如果p是一个普通变量，那么释放的就是p本身
14.分配动态内存后，指向那块内存的变量在函数执行完后就没了，但是那块动态内存还是在的
15.狭义的算法是与数据的存储方式有关（语法不同就不同）
     广义的算法是与数据的存储方式无关 （道理一样就相同）
     泛型（粗略定义，准确的在51）：利用某种技术达到的效果就是：不同的存储方式，执行的操作是一样的
16.静态内存在栈里面分配内存，动态内存在堆里面分配
     栈的定义：一种可以实现让变量先进后出的存储结构
     栈的分类：静态栈，动态栈
     栈的算法：出栈，压栈
17.队列：只能从一头入从另一头出，不能对中间的元素进行操作，也不能插入和删除
     其中front为队列的头，rear为队列的尾，一个元素没了就是出队，加一个元素是入队
     注意出队只能是头部的元素出队，入队只能是尾部的元素入队（把队列看成是排队就行，只能是头部买完东西的人走，尾部的人来排队）
     队列的分类：链式队列（用链表实现的）   静态队列（用数组实现的）
18.静态队列
     静态队列必须是循环队列，头指针front和尾指针rear必须是错开的，必须有一个指针是指向空的区域，比如一个队列有六个位置，
     第123位置都有有效数据了，那么如果front指向第一个元素，那么rear就得指向最后一个有效数据的下一个区域，也就是得指向
    第4个位置，如果front指向第0个位置，也就是第一个有效数据的前一个位置，那么rear就得指向最后一个有效数据也就是第3个位置
    一般来说front指向队列的第一个元素，rear指向队列最后一个元素的后一个元素，所以要记住队列元素个数不包括rear指向的那个元素
   但是包括front指向的那个元素
19.为什么静态队列必须是循环队列？
    举个例子，假设最下面的是队列头部，头指针front指向它，最上面的rear指向有效数据位置的上面那个位置，当出队的时候，必须是
    头部的区域出队，则底部的front必须要往上移，当入队的时候，必须是从尾部入队，那么rear也得往上移，也就是不管出队入队指针
    都是往上移的，这样会导致当指针往上移后，下面的区域就无法使用了，因为没有指针指向它，下面区域的地址丢失了，并且当两个
    指针不断上移，所有的队列空间都会被用完，下面丢失的区域就会造成空间浪费没有使用，所以要把队列的头部和尾部连接起来，当
   两个指针移到最上面的时候，再次上移就会到最下面，这样就可以保证空间不浪费了，所以要把队列头尾相接，看成一个圆，注意数
   队列有几个元素的时候还是从front开始往上数一直到rear停止，不要往下数
20.确定一个循环队列至少需要两个参数，front和rear，两个参数再不同的场合有不同的含义
     队列初始化时：front和rear的值都是零
     队列非空时：front指向队列的第一个元素，reaer指向最后一个有效元素的下一个位置
    队列空时：front和rear的值相等，但不一定是零
21.入队伪算法:入队时是rear指针往上移
    入队时rear指针的指向不一定是它上面的那个空间，可能rear已经指向了最上面的那个位置，这时候对队列进行编号，假设最下面的
    那个空间是0，往上编号逐渐变大，那么rear的指针算法应当是rear=(rear+1)%数组长度，其中rear就是rear指向的区域的编号
    取余的好处就是如果分子小于分母那么最后的结果就是分子，如果分子大于分母还可以使分子变小，这样结果就不可能大于分母，
    当分子大于分母时就会变回小的数字，实现了循环
22.出队伪算法：出队是front往上移，算法仍然是front=(front+1)%数组长度，其中front就是front指向的区域的编号
23.如果front和rear的值相等，即front和rear如果指向同一个区域，那么队列就为空
24.如何判断队列内的元素是否已经满了？
     首先要明确，不能使用front和rear的值相等来判断，因为两者的值相等时，你无法判断队列内的元素是已经放满了还是还没开始放
     第一个方法就是多定义一个参数，入队一个数据就让这个参数+1，当参数值=队列长度的时候队列就满了
     第二个方法就是少放一个数据，比如你定义一个队列长度为6，那你就只放五个数据进去，你自己规定5个数据这个队列就满了，
     也就是你自己定义的时候让队列长度多一个，保证你放入的最大数据个数比队列长度小一个就行，这样就不会出现front和rear相等
     的情况，判断是否已经满的话就可以if(f == (r+1)%队列长度)， 那么队列就满了
     通常使用第二种方式来判断队列是否满了
25.递归就是自己调用自己，要注意编写函数的时候一定要用if写清楚什么时候停止调用自己 
26.一般递归思想：就是解决问题时将它划分为俩个部分，将对大数字进行的操作转换为对多个有规律的小数字的操作。比如就是6的阶乘，
     其实就是要求5的阶乘，只要5的阶乘出来了再乘6就搞定了，求5的阶乘实际就是要求4的阶乘。。。。就这样一直下去。
27.递归调用：直接递归调用和间接递归调用，
      直接递归调用就是在函数内部自己调用自己
      间接递归调用就是函数内部调用其他函数，其他函数再调用自己
28.为什么函数可以自己调用自己？
     只要知道函数a调用函数b和函数a调用函数a两者在计算机看来是相同的操作就行了
     调用一个函数时会执行三步：传递实参，为形参分配空间，给予控制权
     执行完一个函数时也会有三步：保存返回值，释放函数内存空间，交还控制权
     函数的操作实际上是用栈来存储的，在函数a执行的过程中如果又调用了函数a，那么会执行第一个三步曲，为形参分配空间时，其实
     就是把调用函数的内存空间进行压栈，这样第二个函数a就压在了第一个函数a的上面，当执行完第二个函数a时，释放空间其实就是把
     第二个函数a出栈，函数由代码组成，代码是可以多次执行的，那么函数也可以多次执行，那么自己调用自己就是完全可行的，而且
     对于计算机来说，不管是a调用a还是a调用b，都需要执行上面的三步曲，那三步曲都是对内存、控制权、参数进行操作的，与函数的
     名字种类无关，所以计算机调用的时候根本不会说看到这个函数已经使用过了或使用中就不会调用，因为它调用函数的过程完全不需要
     知道这个函数名字，也不会去记忆它有没有用过，它只管按照代码执行下去。
29.递归必须满足的三个条件
     递归必须有一个明确的终止条件
     递归过程中函数处理的数据规模（数据数量）必须在递减
30.循环可以实现的递归一定能实现，但递归可以实现的循环不一定可以实现
     递归的特点：易于理解，但速度慢，占用内存大（因为递归要调用函数，要运行三步曲，所以速度慢）
     循环的特点：不易理解，但速度快，占用内存小
31.如何设计递归：就像数学找规律一样，找到求每一项的规律都是什么，或者将对多个物体操作时将部分物体看成整体，比如对10个物体
     操作，可以将9个物体看成整体，这样就变了对两个物体操作，操作完了再对这9个物体拆除8+1进行操作
32.逻辑结构：
          线性结构：可以用一根线串起来的的存储结构，比如数组，链表（注意：队列和栈是线性结构的应用，是一种操作受限的线性结构）
                           栈和队列是线性结构的表现形式，不是线性结构的一种存储方式
          非线性结构：不能用一根线串起来的存储结构，比如树，图    
33.树的定义：有且只有一个称为根的节点，且有若干个互不相交的子树（子树也叫树）   
     树的组成：节点和边，边就是每个节点的指针域
                    每个节点都只有一个父节点，但可以有多个子节点（根节点例外，根节点没有父节点）
                    最上面那唯一一个的节点就是根节点，下面的都是普通节点
34.每个节点只有一个父节点，比如a-b-c，b是c的父节点，但a不是c的父节点，a是c的祖先  
     每个节点可以有多个子孙，比如a-b-c，bc都是a的子孙
      堂兄弟：顾名思义就是两个节点的父节点都来自一个节点
    深度：从根节点到最底层节点的层数就叫深度，比如a-b-c，就是3层深度
    叶子节点：没有子节点的节点就叫叶子节点（注意：根节点可以是叶子节点也可以是非叶子节点，关键看它下面有没有跟节点）
    非终端节点：就是非叶子节点，就是有子节点的节点
     度：子节点的个数称为度，分为节点的度和树的度，节点的度就是它子节点的个数，树的度就是所有子节点的度中最大的那个
35.树的分类
     一般树：任意一个节点的的子节点个数可以为任意多个
     二叉树：任意一个子节点的个数最多两个，且子节点的位置不可更改
     森林：n个互不相交的树的集合，就是把一堆树就叫森林
     二叉树的分类：
          一般二叉树：每个节点可以有一个子节点，也可以有两个子节点
          满二叉树：所有节点的子节点都是两个，叶子节点在同一行
          完全二叉树：将满二叉树最底层的节点从右往左连续删掉若干个节点（可以不删，也可以删完）
                              不是倒数第二层节点的子节点的右边那个节点，是最后一层所有节点看成在一条线上，从右往左连续删
36.二叉树的存储：所有树的存储都是转换为二叉树的存储来进行的（因为二叉树存储算法比较成熟）
    二叉树存储的分类：连续存储（完全二叉树），链式存储（一般二叉树，满二叉树）
37.连续存储：先把存有有效数据的节点扩展为一个完全二叉树，注意最后删右边的节点时不能把存放有效数据的节点删掉了，
         比如a-b-c-d-e，假如c是存放有效数据的节点，abde都是为了补全为完全二叉树新加的节点，那么删去的时候从右边删除
         只能删除de，不能删掉c，因为不能删掉存放有效数据的节点。扩展为完全二叉树后，将其转换为线性结构存储起来，因为计算机
        只能存储线性结构的数据，而树是非线性的，所以要把他转换为线性结构存储起来
38.为什么连续存储不能只存储有有效数据的节点？
    连续存储是用数组存储的，如果只保留有效节点，那么你就不知道树原本的形状，你不知道究竟谁才是根节点，不知道根节点你就
     不知道该把谁放在数组的第一个元素上，就无法进行存储
39.非线性结构转换为线性结构存储的三种方法：先序，中序，后序
     无论是哪种方法，如果只存储了有效节点，那么就无法推回树的原本形状，那么你把他存储了就没有用了，因为你根本不知道原来的树
     长什么样，你还原树的结果不是唯一的，任何一个有效节点都可能是根节点
40.连续存储的优点：只要知道了节点的编号，你就知道这个节点是在第几层了，因为你把整个树给他补全为完全二叉树了，即使没有
                              子节点的节点都给他补全了子节点，这样每一行的每一个节点都有两个子节点，每一行的节点个数就很好算了
                              并且对于里面的每一个节点，你可以很容易知道它有没有子父节点，它的子父节点的编号是多少都很容易算出来
     连续存储的缺点：非常浪费内存
41.链式存储：每个节点分为三块空间，左边那块空间存放你左边的子节点的地址，中间那块空间存放有效数据
                     右边那块空间存放你右边的那个子节点的地址
     链式存储的优点：可以很方便的寻找子节点，浪费内存很少，而且存储时可以随意存储在任何一块空间，只需要通过指针域连接即可
     链式存储的缺点：较难寻找父节点
42.一般树的存储：双亲表示法，孩子表示法，双亲孩子表示法，二叉树表示法
     双亲表示法：就是先将所有的节点放进一个数组里面去，节点放入顺序无所谓，给每个数组元素加上它们父亲的下标作为编号，
           比如：a-b-c，那么随便把它们放进数组里面，比如放进去是acbd，那么对应的编号就是-1 2 0 2
                         |         a没有父亲，编号为-1，c的父亲是b，b在数组中的下标为2，那么c的编号为2
                         d        b的父亲是a，a的下标是0，那么b的编号为0
     孩子表示法：和双亲表示法类似，只是把数组每个元素的编号改为了存储指针域，存储的是很多个指针，每个指针指向一个它的孩子
     双亲孩子表示法：顾名思义，就是既存储它父亲的下标，又存储它孩子的指针域
     二叉树表示法：就是把一个普通树转换为一个二叉树来存储，具体方法就是设法保证任意一个节点的左指针域指向它的第一个孩子
                            右指针域指向它的下一个亲兄弟（第一个孩子就是最左边的那个孩子），只要满足以上条件，就可以把普通树转换为
                            二叉树，且这个二叉树内的每一个节点一定没有连着原来普通树中这个节点的右孩子
43.森林的存储：转换为二叉树再存储，如何转换为二叉树？就是把森林中的每棵树的根节点当作亲兄弟，从最左边的那个根节点开始画
                         二叉树，让任意一个节点的左指针域指向它的第一个孩子右指针域指向它的下一个亲兄弟（第一个孩子就是最左边的那
	        个孩子）画二叉树口诀：左孩子，右兄弟
44.二叉树的遍历：先序遍历，中序遍历，后序遍历
                          （先序就是第一个访问根节点，中序就是第二个访问根节点，后序就是最后一个访问根节点）
     先序遍历：先访问根节点，再先序遍历左子树，再先序遍历右子树，直到所有节点都被访问
            例如：a-b-d    以a为根节点，先访问a的左子树c，再对c先序遍历，c没左子树，则访问右子树e，再对e执行先序遍历，先访问e的
	      |	   左子树g，再访问e的右子树f，这样e就访问完毕，回去c只有一个子孙，则c访问完毕，回去a，访问a的右子树b，
	      c-e-f     再访问b的左子树d，整颗树访问完毕，先序遍历得到的线性结构为acegfbd
	         |
	        g	
    中序遍历：中序遍历左子树，再访问根节点，再中序遍历右子树
           例如：a-b-d    以a为根节点，先中序遍历左子树c，则下一步中序遍历c，则先访问c的左子树，c没有左子树，则访问c，然后访问
	      |	  c的右子树e，然后中序遍历e，则先访问e的左子树g，然后访问根节点e，然后访问e的右子树f，这样e访问完毕，
	      c-e-f     返回c，c的右子树也访问完毕，c也访问完毕，返回a，a的左子树访问完毕，然后访问a，然后访问a的右子树b，
	         |        然后中序遍历b，先访问b的左子树，但b的左子树为空，则访问b，然后访问b的右子树d，全部节点访问完毕
	        g        中序遍历的线性结构为cgefabd
    后序遍历：后序遍历左子树，后序遍历右子树，再访问根节点
           例如：a-b-d    以a为根节点，后序遍历c，没有左节点，则下一步访问右节点e，后序遍历e，则先访问左子树g，再访问右子树f，
	      |	  再访问根节点e，e访问完毕返回c，c的右子树访问完毕，访问根节点c，c访问完毕，返回a，a的左子树访问完毕
	      c-e-f     开始访问右子树b，后序遍历b，先访问b的左子树，没有左子树则访问右子树d，然后访问根节点b，最后返回a
	         |         访问根节点a，所以后序遍历的线性结构为gfecbda
	        g
45.已知先序中序，或已知中序后序都可以推出原始的二叉树，但已知先序和后序无法推出原始的二叉树
     即必须要知道中序才可以推出原始二叉树
46.已知先序中序，还原二叉树并求出它的后序
     先看先序，第一个出现的一定是整颗树的根，在中序中找到这个根，那么中序中这个数左边的都是左子树，右边的都是右子树
     于是就可以把先序中的字母划为三部分（根节点左子树右子树），再看先序中左子树区域的第一个字母一定是左子树的根节点
     先序中右子树区域的第一个字母一定是右子树的根节点，再看中序中这个根节点字母在哪里，来判断它有没有左子树，接下来
      就按照先序中序交替看，先序确定根节点，中序确定剩下字母在根节点左边还是右边来慢慢还原二叉树
     （先将先序中序分为三部分，确定三个根节点，然后按照先序中序先序中序的顺序交替看，先序找根节点，中序确定左右子树）
    例如：先序abcdefgh      中序bdceafhg
         先序中第一个字母为a，那么a一定是整颗树的根节点，根据这个a，就可以在中序中看到a的左边的bdce为左子树，右边的fhg为
         右子树，则先序中的bcde为左子树，fgh为右子树，看先序中b为左子树根节点，恰好为中序中的第一个字母，则说明b没有左子树
         右子树为dce，再看先序，第三个字母为c，那么c为根节点，再看中序，c在de中间，那么c的左子树为d，右子树为e，再看a的右
         子树，第一个是f，则f为根节点，中序中f为第一个字母，则f没有左子树，右子树为hg，再看先序，g为第二个，则g为根节点，
         再看中序，h在g的左边，那么g的左子树为h
47.已知后序和中序求原始二叉树和先序的时候也是一样的，只是找树的根节点的时候在后序的最后面那个字母才是根节点
     （先将后序中序分为三部分，确定三个根节点，然后按照后序中序后序中序的顺序交替看，后序找根节点，中序确定左右子树）
     例如：中序bdceafhg      后序decbhgfa
           先看后序最后一个字母是a，那么a就是整棵树的根节点，看中序a的左边是bdce为左子树，a的右边是fhg为右子树
           看后序中decb为左子树，hgf为右子树，那么左子树的根节点是b，右子树的根节点是f，先看左子树，看回中序，b是第一个字母
          那么dce都是b的右子树，看回后序，c是倒数第二个，那么c是根节点，看回中序，d在c的左边，那么d为c的左子树，e在右边，
         那么e是c的右子树，返回a，f为右子树最后一个字母为根节点，返回中序hg在f的右边，则hg为f的右节点，返回后序，g为根节点
         返回中序，h在g的左边，则g的左子树是h
48.树的应用
     树是数据库中数据组织的一种重要形式
     操作系统子父进程的关系本身就是一棵树
     面向对象语言中类的继承关系
49.  排序和查找的关系：排序是查找的前提    
50.数据结构研究的是数据的存储和数据的操作的一门学问
    数据的存储分为两部分：个体的存储        个体关系的存储
         个体的存储就是一个基本变量，例如int i这个i变量的存储
        个体关系的存储就是链表之类的有基本变量数据，又有其他区域的地址的变量的存储
   从某个角度而言，数据的存储最核心的就是个体关系的存储，个体的存储可以忽略不计
51.什么是泛型？
    同一种逻辑结构，无论该逻辑结构物理存储时什么样子的，我们都可以对它执行相同的操作
    即都得是线性存储（链表）   或    都得是树形存储（二叉树）
52.哈夫曼树：在树的种类相同时，带权路径长度最短的就是哈夫曼树
     路径：就是树的边
     结点的路径长度：即从一个节点到另一个节点的边个数
    树的路径长度：就是根节点到所有节点的路径长度之和
    节点数相同时，完全二叉树是路径长度最短的二叉树，但是路径长度最短的不一定是完全二叉树，因为只要最后一行节点相同路径长度
     就相同，但是完全二叉树要求剩余的节点都得在左边，其他树剩余的节点可以在最后一行的任何位置
    权：树中的节点中包含的数据就是该节点的权（就是这个数据占总数据的百分之几）
    节点的带权路径长度：根节点到该节点的路径长度  乘  该节点的权
     树的带权路径长度：树中所有叶子节点的带权路径长度之和
   满二叉树不一定是哈夫曼树
53.如何构造哈夫曼树（已知叶子节点权的情况下）
     把权值大的放到上面的叶子节点，权值小的放到下面的叶子节点
    注意：哈夫曼树不唯一！！！

    构造哈夫曼树要从底部开始搭建，先选两个最小的作为底部的两个叶子节点，它们的根节点的权是两者权的和，然后再从原始树和新造
    的根节点中选出两个最小的组成新的子树，如果其中一个是新造的根节点，另一个是原始节点，那么原始节点就与根节点同一层，那么
    树会往上扩展一层，如果此时最小的两个都是原始树中的，那么就把这两个节点与此时的新树平行建，此时这两个节点又会产生一个新
    的根节点，下一步就变成了在两个新的根节点和剩余的原始节点中找两个最小的，这样一直重复下去，直到原始节点全部都变成了新树的叶子节点

   注意：哈夫曼树一定是二叉树，没有一个节点的只有一个子节点
   包含n个叶子节点的哈夫曼树共有2n-1个节点，因为n个叶子节点一定要合并n-1次，就会多出n-1个节点，那么合完就有n+n-1=2n-1个
54.哈夫曼编码：节点的左子树路径为0，右子树路径为1，将根节点到该叶子节点路径上的所有编号拼起来就是哈夫曼编码
    前缀编码：就是保证这个编码不会出现有两个其表示的字母重合的情况，比如A用00表示，B用0表示，那么00就可能使一个A或两个B
	    但是前缀编码一定不会出现这种情况
   哈夫曼编码一定使前缀编码，因为所有根节点到叶子节点的路径都是唯一的，不会经过其他的叶子节点，也就不会出现编码和其他叶子节点重合的情况
   哈夫曼编码是树编码中最短的字符编码，因为哈夫曼树的带权路径长度最短，是最优树
55.如何通过哈夫曼树表格推出哈夫曼树编码
     从叶子节点开始，找到叶子节点的父亲，看是它的左子树还是右子树，编号为0或1，这个编号要放到一个指针数组cd中，并且要倒着放进去，因为
    哈夫曼编码是从根节点到叶子节点读取编码，这个是反过来从叶子节点开始读取的。有关指针数组cd，它的长度是叶子节点个数，假设有n个叶子节点
    那么就需要构造n-1次才能出来哈夫曼树，那么这个树最多就只有n层，每上一层只会读取一次编码，那么编码长度最长也只能到n-1，之所以要构造长度
   为n的指针数组，是因为最后一位要存放\0，确保后续能正常输出。一开始指针指向数组最后一个元素\0的前面一个位置，每放进去一个元素指针就往前
   移一个，先找叶子节点的父亲，看是它的左子树还是右子树，在找叶子节点的爷爷，看叶子节点的父亲是爷爷的左子树还是右子树，就这样一直找下去
   直到找到树的根节点（即哈夫曼树表格中根节点是没有父节点的，它父节点的编号是0，不是任何一个节点的编号），然后从指针数组的指针指向的位置
  开始输出就可以得到这个叶子节点的哈夫曼编码，而所有叶子节点的哈夫曼编码都会被放到一个指针数组HC中，通过指针HC访问动态内存获取哈夫曼编码
56.图：包括两个集合，一个集合是顶点的集合，顶点就是数据对象，一个是边的集合，边就是数据关系
            要求顶点和边的集合必须是有限的，且顶点的集合不能为空
    图的分类：无向图--每条边都是无方向的
	    有向图--每条边都是有方向的
 	    完全图--图中任意两个点都有一条边相连
		无向完全图--有n个顶点，就要有n(n-1)/2个边
		有向完全图--有n个顶点，就要有n(n-1)个边
	    稀疏图：有很少边或弧的图（边小于nlogn）（无向的叫边，有向的叫弧）
	    稠密图：有很多边或弧的图
	    网：顶点之间的边具有权，就是边上存了数据，表示了两个顶点之间的一些关系（距离之类的）
	    连通图：任意两个顶点之间都存在着路径相连就是连通图（不一定是一条线连起来两个点，中间经过别的点到达也可以）
		 无向图中叫连通图，有向图中叫强连通图
	               注意：有向图中有一条边连起来不能说两个顶点连通，因为边是有向的，是单向连通不是双向连通
		       但是有向图中若两个点可以通过其他点连接起来，也可以叫做连通图
	   子图：对于两个图ab，若b有的点a也有，b有的边a也有，那么b就是a的子图
57.专业术语 
         邻接：顶点与顶点的关系，两个顶点之间有边或弧就是邻接的（v，y）表示vy互为邻接点  <v,y>表示v邻接到y或y邻接于v
         关联（依附）：边与顶点的关系，若存在（v，y） <v,y>则表示该边或弧关联于vy
         顶点的度：与顶点相连的边的个数（在有向图中分为入度和出度，有向图的度是两者的和）
	          v的入度就是以v为终点，有多少个弧指向它，出度则相反，把v作为起点（仅一个点入度为0，其余点入度为1的是一颗有向树）
         路径：连续的几条边关联的几个顶点的序列叫做路径
         路径长度：路径上边或弧的数目（有时是权）的和
         回路/回环：就是第一个顶点和最后一个顶点相同的一条路径
         简单路径：除了起点和终点可以相同，中间路过的所有顶点不能有重复的一条路径
         简单回路：起点和终点必须相同，中间路过的所有顶点不能有重复的几条路径
        连通分量：就是把一个图a拆成若干个连通图，不连通的点和边移开，连通的点和边保留，这样形成的若干个连通图就是这个图a的连通分量
	         在有向图中叫做强连通分量
	         让每一个子图都在保证连通的前提下尽可能多加一些顶点，每一个都是图a的极大连通子图（可连通的顶点数已经达到最大）
	         照着上面的方法，先把一个图a拆成若干个连续图，然后对那若干个连续图操作，在保证仍是连通图的前提下尽可能的删除掉多的边
                         当边已经删到不能再删时，每一个子图就叫做极小连通子图（边的存在数目已经达到最小）
       生成树：对于一个极小连通子图（无向的），把这个子图画成一颗树（转一转它的边和顶点变成一颗树的样子就行）
       生成森林：一个图的所有极小连通子图生成的树的集合
58.图的存储结构：采用顺序存储（一维数组）太复杂，应该采用二维数组表示法（邻接矩阵）或者用链式存储结构
	            其中链式存储分为--邻接表，临界多重表，十字链表
59.顶点表vexs，一个一维数组，存储的是图中的顶点的名字（下标）
     邻接矩阵：二维数组arcs，如果两个下标为i，j的顶点之间没有弧或边，那么arcs[i][j]的值为0，反之若两个顶点之间存在边，则arcs[i][j]的值为1
     邻接矩阵的大小：有几个顶点，就创建几*几的方阵，比如有3个顶点，就创建一个arcs[3][3]
	               因为要表示任意两个顶点之间的关系，那么任意一个点都需要对应所有的点，那么每一行就有n列，有n行的话大小就是n*n
60.若邻接矩阵是无向图的，且一次填表要填两个空，比如下标分别为1、2的两个顶点之间有边，那么可以说1到2有边，也可以说2到1有边
	所以arcs[1][2]和arcs[2][1]的值都是1。但是有向图的两个值不一定相同
               而且要注意自身与自身没有边，也就是arcs[1][1],arcs[2][2]的值都是0，两个下标一样的顶点是同一个顶点，同一个顶点之间没有边
     通过邻接矩阵计算顶点的度：就是计算那个顶点下标对应数组的那一行的所有值的和
     特别的，完全图的邻接矩阵所有值都是1
61.若邻接矩阵是有向图，记得按行填写，是一行一行写，不是一列一列写，即竖着的编号是起点，横着的编号是终点
     如果编号为1的与编号为2的有边，那么是arcs[1][2],也就是第一行第二列的值为1
     邻接矩阵中有几个1，图中就有几条边
     顶点的出度 = 顶点所在的那一行的所有数字的和
     顶点的入度 = 顶点所在的那一列的所有数字的和
62.若邻接矩阵是有向图（网），那么如果两个顶点之间有边，那么arcs[i][j]的值就是两个顶点之间的边的权，如果两个顶点没有边，则值为无穷
     如果两个顶点相同，即两个相同的顶点（邻接矩阵的对角线，横纵坐标相同）时，值为0
63.访问结构体的时候什么时候用->，什么时候用.
     当形参接收的是结构体变量的地址，那么访问结构体数据的时候就用->
     当形参本身就是那个结构体变量，或接收的是结构体变量本身而不是它的地址，用.
64.邻接矩阵存储图的优点：能非常直接的获取图的基本信息（顶点个数，顶点关系，度）
     邻接矩阵存储图的缺点：不便于增加和删除顶点，存稀疏图（点多边少）时非常浪费空间（它的大小是看有n个点就n*n大，不管里面有多少条边）
		         统计图中有多少条边的时候很浪费时间（有很多没有边的点占据了邻接矩阵的内存空间）
65.邻接表（适用于存储稀疏图）
     用链表存储图：先存储顶点编号，然后指针域保留下一个节点的地址，下一个节点存储这个顶点的第一个邻接顶点的编号，这样一直链式下去
	            直到这个顶点的所有邻接顶点都存储完毕
	            如果是有向图，那么一个节点除了存储顶点的编号，还要存储边的权和下一个节点的地址
    比如：编号1连接着23，那么1 ->  2  ->3 (2,3的位置可以换，没规定先存储哪个顶点)
    如果有n个顶点，e条边，那么就需要n个头结点，2e个表节点（头结点就是链表的第一个节点，表节点就是头结点后面的所有节点）
    邻接表中有几个表节点那个顶点的度就为多少（无向图）
    邻接表有多个出度点的时候，优先存储编号大的点（逆邻接表也是优先存储入度点编号大的点）
    有向图的邻接表链式存储时既可以存储顶点的出度点，也可以存储顶点的入度点
    存储出度点时，顶点的出度就是那个顶点对应的表节点的个数，入度就是整个邻接表中存储了这个顶点编号的表节点个数
    所以寻找出度简单，只需要遍历一个头结点，但寻找入度难，需要遍历整个链表
    当然，也可以创建一个逆邻接表，链表存储指向该顶点的顶点编号，即存储入度点，这样就变成寻找入度容易，寻找出度难了
66.邻接表的特点：方便寻找任何一个顶点的所有邻接点，但是当要判断两个顶点间是否有边时，需要遍历整个邻接表，非常浪费时间
67.邻接表和邻接矩阵的关系
     联系：顶点的邻接点个数=邻接矩阵中那个顶点对应的那一行的数字和=邻接表中那个顶点对应的头结点的表节点个数
     区别：对于任意一个无向图，邻接矩阵时唯一的，邻接表不是唯一的（邻接点的次序可能不一样）
     邻接矩阵多用于稠密图，邻接表多用于稀疏图
68.十字链表：解决有向图只存储出度点或入度点的问题
      就是让链表的头结点节点从两部分变成三部分，分别存储顶点编号，出度边指针和入度边指针
                  表节点变成四部分，分别存储边的左、右顶点，以及下一个同类型弧的指针域（两个，一个出度一个入度）
  拿出度边举例，头结点里面的第二个区域存储出度边的地址，指向下一个表节点，下一个表节点的第一二个区域存储了两头的顶点编号
  第三个区域是存储入度边的指针域的，这里讨论出度所以不用，第四个区域就存储了下一个该顶点的出度边的地址（若没有就为空）
  注意：               对于有向图的弧->     左边是弧尾，右边是弧头               
69.邻接多重表：解决无向图每条边要存储两次的问题
     方法：就是把表节点变成五部分，第一部分作为标志域，对邻接多重表操作的时候才会用到，第二四部分用来存放边所连接的两个顶点的编号，
         第三五部分作为指针域，先确定一个储存顺序，一般确定是从编号小的开始存储，如果是以第二部分的顶点编号为起点，那么就让第三部分指针域
         指向下一表节点的第三部分（确保同一个头结点的指针是一条线下去的，不能前一个指向第五部分，后一个就从第三部分出发，这样就不是一条线了）
         如果是以第四部分的顶点编号为起点的，那么就让第五部分指针域指向下一表节点的第五部分，当第一次关联新顶点时
         头结点可以直接指向新表节点，如果是已有的关系，则头结点需指向那个表节点的第三或第五部分
     比如：1-2-3，先存储1，创建一个（ 1 2 ）的表节点，头结点直接指向这个表节点，这样1的边就存储完毕，然后到2，由于21之间的边之前已经存过
          一次，而这次是以2为起点的边，所以2的头结点应该指向表节点（ 1 2 ）的第五部分，然后到23之间的边，之前没有存过，所以新创一个表节点
         （ 2 3 ），之前表节点（ 1 2 ）的第五部分则跟着指向下一个表节点（ 2 3 ）的第三部分（因为是以2为起点的）
70.图的遍历
     从某一个顶点出发，沿着边访问图中的所有顶点，且每一个顶点只能被访问一次，注意是只能访问一次，不是只能经过一次，可以多次经过，但只能
     遍历一次（可以设置一个数组来确定这个顶点有没有被访问过，比如创建一个a[6]，a[1]为0就是顶点1没有被访问过，a[1]为1就是顶点1被访问过了）
71.图的深度优先遍历(DFS)
     过程：从某一个顶点开始，先选择一个方向，访问下一个没被访问过的顶点，之后重复上述操作，一直自己确定路线访问下去，只要这个顶点没有被
     访问过，就一直访问下去，直到无路可走或周围的邻接点都被访问过了，就回退一个顶点，看这个顶点周围是否存在没访问过的顶点，如果没有就再
     回退一个顶点，如果有就从这个方向继续访问下去，直到回退到作为起点的那个顶点时，那个顶点周围的顶点的路线都走过了，且都无路可走一直回退
     到起点时，就算遍历完毕
72.图的广度优先遍历（BFS）
      确定一个顶点作为起点，先把这个顶点的所有的未访问过邻接点给访问了，然后在进入下一层，对起点的一个邻接点再次执行上述操作，先把这个
    邻接点周围所有的连着的未访问的邻接点给访问了，然后再对起点的另一个邻接点再次执行上述操作，把这个邻接点周围所有的连着的未访问的邻接点
    给访问了，等起点周围的邻接点都被执行过上述操作后，在进入下一层，对起点的一个邻接点的一个邻接点的所有为访问邻接点进行访问，直到最后
    一层的顶点执行完上述操作，遍历完毕（注意有时会存在一些不连通的图，要对不连通的图当成一个新图，重新执行广度优先遍历）
73.时间复杂度超牛文章
     https://zhuanlan.zhihu.com/p/444038316
74.图的应用
    生成树：所有顶点都连接在一起，但不存在回路的图。就是把边拼起来不能拼成一个封闭图形
         生成树的顶点个数与图的顶点个数相同，生成树是图的极小连通子图，n个顶点的连通图的生成树有n-1条边,但含n个顶点n-1条边的图不一定是生成树
         一个图可以生成许多不同的最小生成树，在生成树中再加任意一条边一定形成回路，生成树中任意两个顶点之间的路径是唯一的
    生成树过程：就是运用深度遍历或广度遍历一个图，如果遍历时这个顶点的一个邻接点已经遍历过了，就不保留这个顶点和邻接点之间的边
	如果这个顶点的邻接点没有遍历过，那么就遍历这个邻接点同时保留顶点和这个邻接点之间的边
    最小生成树（MST）：对于一个边带权值的网，它有很多生成树，其中权值和最小的那个生成树就是最小生成树（最小生成树不一定唯一）
    应用：不同城市之间建立连通网时，不同城市之间的通讯线可以当作边，建造费用当作权值，如果要保证每个城市之间都连通，即都能覆盖连通网
              就需要把生成城市的生成树，如果要最省钱（生成树权的和最小），就需要生成最小生成树
    MST性质：任取一个还没放在生成树上的顶点，将剩余的顶点放到一个集合里面去，然后从集合中挑出这个顶点的所有邻接点，再从中选出一个与该
                    顶点之间权值最小的邻接点，那么这个顶点和这个邻接点之间的这条边一定会包含在这个图的最下生成树中
75.最小生成树过程：
   算法1普利姆算法（prim）：先将任意一个顶点作为初始点，放进最小生成树中，然后找这个顶点的所有的未放进生成树上的邻接点，找到它们之间
         权值最小的边，把这条边关联的那个邻接点纳入生成树中，同时保留它们之间的边。然后继续下去，找到已纳入生成树的所有的顶点，然后找到
        这些顶点与未纳入生成树的其他顶点的所有的边，从中选一个权值最小的边，确定加入这个边和对应连接着的邻接点后生成树不会形成闭环的话，就
       纳入这个边和这个邻接点，如果会形成闭环就找第二小的，就这样一直重复下去，继续寻找已在生成树上的三个顶点的所有邻接点，找它们与其他顶点
       之间权值最小的边，一直到所有的顶点都纳入生成树后，最小生成树就完成了（稠密图）
76.最小生成树算法2：克鲁斯卡尔算法（kruskal）
     过程：直接把所有的顶点加入到生成树中，然后搜寻原图中权值最小的边，把这个边加到生成树中，之后就把第二小的边加入到生成树中，但是要注意
        加入的边不能让生成树形成环，就这样一直选取最小的边加入到生成树中，直到生成树中的所有顶点连通（稀疏图）
77.最短路径：有向图中两个顶点之间有多条路径，各边的权值之和最小的那条路径就是最短路径 
       这个最短路径可以是两个隔得很远的两个点的路径，也可以是两个相邻的点的路径
     常见最短路径问题：两点之间最短路径是多少？一个点到其他所有点的最短路径分别是多少？
78.一个点到其他所有点的最短路径分别是多少：算法--迪杰斯特拉算法dijkstra
    设定两个集合，第一个集合s是已经找到最小路径的顶点，第二个集合t是还没有找到最小路径的顶点，一开始s集合中只有初始顶点v0，其他顶点全部
    在t集合中，然后计算初始点v0到各顶点的路径长度，如果可以直达（通过一条边连起来），那么路径长度就是那个边的权值，如果不能直达（要通过
    其他点才能到达），那么路径长度就是无穷，计算完所有的点到v0之间的路径长度后，从中选取一个路径长度最短的点（若有两个点相等，选序号小的）
   假设这个点是v1，那么这个路径长度就是v1的最小路径长度，那么就把v1加入到s集合中，之后就判断v0到t集合中所有顶点的路径长度有没有因为v1而
   改变，后面你就开始计算v0通过v1顶点可以到达的点的路径长度，这个路径长度是v0与v1之间的路径长度+v1到那个点的路径长度，看看这个路径长度
   和原来v0直达时有没有变小，变小了就替换掉原来的值，没变小就沿用原来的值，重新计算完后再从中选取一个路径长度最小的顶点加入到集合s中（假
  设加入点为v2），判断v0通过v1和v2（可以只通过其中一个点，也可以两个点都通过），v0到t集合中的顶点的路径长度有没有变化，变小就改，没变小
  就沿用，就这样一直下去，直到所有的顶点都加入到s集合（别漏了判断最后一个t集合中的顶点有没有因为前一个顶点加入到s中而导致v0到这t中最后一个
  顶点的路径长度改变）
79.每一个顶点到所有顶点之间的最短路径：算法--弗洛伊德算法floyd
     首先先建立一个表格，表格大小是n*n（n为顶点个数），横纵坐标分别为各顶点编号，对角线上的值为0（自己与自己之间没有路径长度），然后把每一
     个顶点到其他所有顶点之间的路径长度填进去（如果直连就填权值，不直连就填无穷大），然后试着逐渐加入其中的某一个顶点作为中间顶点，看其他
     顶点通过这个顶点到其余顶点的路径长度有没有变化，变小了就更换表格中两点的路径长度的值，没变化就不管他，直到所有的顶点都做过一次中间顶点
     后，算法结束，输出表格
80.有向无环图的表示：AOV网和AOE网
     AOV网：以顶点表示活动，边表示活动之间的优先制约关系
     AOE网：边表示活动，顶点表示活动的开始和结束
81.AOV网：在一个有向图中边表示优先制约关系，比如a->b->c就表示必须先经过a才能经过b，就像学习一样，必须先学习了c语言才能学习数据结构
      在这个图中ac之间没有直接连接但是可以通过中间点到达的，a就是b的前驱，b就是a的后继
      在这个图中ab之间是直接连接的，那么a就是b的直接前驱，b就是a的直接后继
     注意：AOV网中不能有回路（用拓扑排序判断是否有回路）
82.拓扑序列（不唯一）：在AOV网没有回路的前提下，把全部活动（顶点）排列成一个线性序列，使得AOV网中的弧<i,j>在线性序列中，i一定排在j的前面
    拓扑排序：选取一个没有前驱的顶点放进序列中，把这个顶点和以这个顶点为弧尾的边删去（优先选取序号小的顶点），注意没有箭头的那一端才是弧尾，
                    然后重复以上操作，继续选取一个没有前驱的、序号小的顶点放进序列中，删除图中的这个顶点和以它为弧尾的边，直到图中所有的顶点都给
                    删除，排序结束
     如何通过拓扑排序判断网是否存在环：若拓扑排序后的拓扑序列包括了图中的所有顶点，那么这个图一定没有环
83.最迟问题：如果要完成一项工作，每个小工作都需要花费一定时间且有部分小工作之间有先后顺序，那么最迟什么时候开工
                   解决这样的问题，都有一个最终目的，最迟开工的话中间是有些步骤可以省略的
     AOE网，边为活动时间，顶点表示后一个活动的开始，或者叫前一个活动的结束，事件开始的顶点为源点，事件结束的点叫汇点
     AOE网中两个顶点之间可以有多条方向一样的弧，表示在前面那个活动结束后这两个活动都可以进行（但不能同时进行），且后面那个活动必须要这
       两个活动都完成了才能进行（有些活动的前置任务可能不止一个，所以会出现两个顶点之间多弧的情况）
84.解决最迟问题：AOE网+关键路径（加快关键路径上的活动速度，能缩短整个工程的完成时间）
    关键路径：从源点到汇点路径长度（权值之和）最大的路径，关键路径可能不止一条（所有关键路径上的活动都需加快，才能缩短工期）
    关键路径描述量：ve（vj）--事件vj最早发生时间--ve（v1）=0，就是以v1为起点的事件的最早发生时间是0时（一开始就可以发生）
	               vl（vj）--事件vj最晚发生时间--vl（v4）=50，就是以v4为起点的事件的最晚发生时间是50时
	               e（i）--表示活动ai的最早开始时间--e（a3）=20，就是活动a3最早可以在30时开始
	               l（i）--表示活动ai的最晚开始时间--e（a4）=60，就是活动a4最晚可以在60时开始
	              活动余量：l（i）-e（i）--就是在这段时间内干什么都不会影响活动ai的进度
		关键活动：就是时间余量为0的活动，也可以说是l（i）和e（i）相等的活动
			由关键活动构成的路径就是关键路径
    公式：e（i）=ve（j）         ve（j）是弧尾那个点的最早发生时间
              l（i）=vl（k）-事件权值      vl（k）是弧头的那个点的最迟发生时间     （即ei和li都依附于求出ve和vl）
             ve（j）=max{ve（i）+事件权值}        就是前一个ve最大的事件的最早发生时间+最大的权值，因为这个事件前面的事件可能不止一个，
				有很多事件指向它就这样一直往前推，直到第一个顶点（源点），源点的ve（i）=0
				选大权值是因为要进行后面的活动必须保证前面的事件都完成，所以要选大的时间保证所有事件都能完成
 				前面是单点多边时选最大的权值，前面是多点单边时就一个个加，看哪个顶点+权值的值最大
 				单点多边就是前面只有一个顶点，但是这个顶点又很多弧与他关联
				多点单边就是前面有很多个顶点，但是每个顶点只有一条边与他关联
             vl（i）=min{vl（j）-事件权值}     与上面相同，选权值较大的，因为要从后一个往前推，后一个事件的vl要选最小的，要让vl-权值最小，那么权值
				就得最大，就这样一直往后推，直到汇点，汇点的vl是确定的（汇点的最早发生时间和最晚发生时间相同）
				选大的权值的是因为你要保证后面所有活动都能完成，所以要保证时间最长的活动也能完成
				后面是单点多边时选最大的权值，后面是多点单边时就一个个减，看哪个顶点-权值的值最小
85.查找：在查找表中查找与一个给定的数据相符合的数据
     查找表：由同一类型的数据元素构成的集合，类似于平时的成绩表
     关键字：就是给定的数据，分为主关键字和次关键字，主关键字就是根据这个关键字只能找到一个唯一对应的数据，次关键字就是可以找到多个对应的
	  数据
     查找是否成功：可以设定一个指针，如果成功就输出信息同时指示位置，如果不成功可以返回空指针
     查找的目的：寻找有没有这个数据，寻找这个数据的相关信息，对这个数据进行删除增加等操作
     查找表的分类：静态查找表--仅对查找表进行遍历、查询等操作
	            动态查找表--会对查找表进行插入、删除数据等操作
     如何评价查找算法：平均查找长度ASL--关键字的平均比较次数
		ASL= pi*ci的和，其中i=1~n，n为记录的个数，pi为查找第i个记录的概率(一般为1/n)，ci为找到第i个记录所需的比较次数













 
















